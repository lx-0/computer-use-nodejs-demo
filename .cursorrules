// Awesome CursorRules for LLM-controlled Computer Application
// Guidelines: @<https://raw.githubusercontent.com/PatrickJS/awesome-cursorrules/refs/heads/main/.cursorrules>

// Project Information
// This application uses a large language model to control a computer.
// It has two modes: local system control and virtual machine control (via Docker).
// Capabilities include: screenshot analysis, mouse control, keyboard control,
// bash execution, and file management.

// Tech Stack
// - Next.js with TypeScript for the main application
// - Node.js for system interactions
// - Docker for virtual machine control
// - VNC for graphical interactions with the virtual machine
// - Electron for desktop application packaging

// Docker Integration Features

- Use dockerode for Docker API interactions
- Support building images from local Dockerfiles
- Stream build progress in real-time to chat interface
- Handle container lifecycle (start, stop, delete)
- Display container status and details in dropdown menu
- Support both local Dockerfile and remote image builds
- Provide build progress updates in chat log
- Auto-scroll chat to latest messages
- Expandable log entries with copy functionality
- Wait for build completion before starting container

// Chat Interface Features

- Collapsible log messages with detailed view
- Real-time build progress updates
- Copy-to-clipboard functionality for logs
- Service-specific message attribution (e.g., "Docker:")
- Auto-scrolling to latest messages
- Truncated status details with full copy support
- Build progress streaming with error handling
- Two-line status display in Docker menu

// Docker Container Configuration

- Support for VNC server setup
- NoVNC integration for web-based access
- Environment variable configuration
- Port mapping for required services
- Proper entrypoint script handling
- User permission management
- Python environment setup
- Desktop environment configuration

// Error Handling

- Proper error display in chat interface
- Build failure detection and handling
- Container start/stop error management
- Stream disconnection handling
- Status update error handling

// UI/UX Features

- Responsive split view layout
- Settings sidebar integration
- Docker status icon with state indication
- Dropdown menu for container actions
- Real-time status updates
- Proper loading states and indicators

// Startup Modes
// - CLI: Execute specific LLM tasks defined by command-line parameters
// - Electron App: Launch as a desktop application
// - Web Browser: Serve via Next.js server

// Feature Requirements

- Implement a chat interface for user interaction with the LLM
- Provide both local system control and remote Docker container control options
- Include a settings sidebar for configuration options
- Implement a resizable split view between chat and VNC screen
- Ensure responsive design for all components, especially the VNC screen
- Implement screenshot capture and analysis
- Implement mouse and keyboard control for both local and remote systems
- Implement bash command execution
- Implement file management capabilities
- Support CLI mode for executing specific LLM tasks
- Package as an Electron app for desktop use
- Serve as a web application via Next.js server
- Allow users to select and build Docker images from available Dockerfiles
- Start a default Docker container on application load
- Display Docker container status and details in a dropdown menu
- Provide expandable log entries in the chat interface
- Implement copy-to-clipboard functionality for Docker container details

// General guidelines

- Always use TypeScript for better type safety and maintainability
- Maintain clean code principles and follow best practices
- Use strict and explicit typing; never use the 'any' keyword
- Follow DRY principle wherever possible

// Project structure

- Organize the project into components, pages, and API routes
- Use Next.js for the web application framework
- Implement both local system control and Docker container control
- Create separate entry points for CLI, Electron, and web modes
- Store Dockerfiles in a 'data/dockerfiles' directory

// Coding standards

- Use async/await for asynchronous operations
- Properly handle errors and exceptions
- Use meaningful variable and function names
- Add comments for complex logic or non-obvious code

// CLI Mode

- Implement a CLI interface using a library like commander or yargs
- Parse command-line arguments to define LLM tasks
- Execute LLM tasks without launching the full UI

// Electron Mode

- Use Electron-builder for packaging the desktop application
- Implement IPC (Inter-Process Communication) for Electron main and renderer processes
- Ensure proper security settings for the Electron app

// Web Mode

- Use Next.js API routes for backend functionality
- Implement server-side rendering where appropriate

// React and Next.js specific

- Use functional components with hooks
- Implement server-side rendering where appropriate
- Use Next.js API routes for backend functionality

// UI Components

- Use Radix UI primitives for accessible components
- Implement custom UI components using Tailwind CSS
- Use Lucide React for icons
- Implement a dropdown menu for Docker-related actions

// State Management

- Use React hooks (useState, useEffect, useCallback) for local state management
- Consider using React Context or a state management library for global state if needed

// Styling

- Use Tailwind CSS for styling components
- Implement responsive design for all components
- Use CSS modules or styled-components for component-specific styles if needed

// API and Backend

- Implement API routes for system control actions
- Use child_process for executing system commands (in a secure manner)
- Implement proper error handling and validation for API requests

// Docker Integration

- Use dockerode for Docker API interactions
- Implement SSH connections to containers using ssh2
- Use VNC for graphical interactions with containers
- Support building images from local Dockerfiles
- Implement listing available Dockerfiles
- Allow starting containers from both remote images and locally built images
- Provide a dropdown menu in the UI for Docker-related actions
- Display detailed container status and logs in the UI

// Security

- Implement proper authentication and authorization for API routes
- Use secure practices when executing system commands
- Sanitize and validate all user inputs
- Implement appropriate security measures for Electron app

// Performance

- Optimize components for performance, especially the chat and VNC components
- Use React.memo or useMemo for expensive computations
- Implement virtualization for long lists if needed

// Accessibility

- Ensure all components are accessible (ARIA attributes, keyboard navigation)
- Use semantic HTML elements

// Testing

- Write unit tests for components and utility functions
- Implement integration tests for API routes
- Use Jest and React Testing Library for frontend tests
- Add tests for CLI functionality

// Dependencies
Ensure all required dependencies are properly installed and typed:

- next
- react
- react-dom
- @radix-ui/react-*
- lucide-react
- tailwindcss
- class-variance-authority
- clsx
- tailwind-merge
- dockerode
- ssh2
- node-pty (for terminal emulation)
- xterm.js (for terminal UI)
- electron
- electron-builder
- commander or yargs (for CLI)

// TypeScript configuration

- Ensure strict mode is enabled in tsconfig.json
- Use path aliases for cleaner imports

// Maintenance

- Regularly update dependencies to their latest compatible versions
- Keep the codebase modular for easy maintenance and feature additions

// Documentation

- Add JSDoc comments for functions and components
- Maintain a README with setup and development instructions
- Include documentation for CLI usage, Electron app, and web mode

// LLM Integration Features

- Use Langchain.js for LLM abstraction
- Implement secure backend-only API calls
- Support function calling for system control
- Handle streaming responses
- Manage conversation context
- Support multiple LLM providers
- Support model selection and switching
- Track model usage in messages
- Implement proper error handling
- Add response validation
- Support function execution tracking
- Add message history support
- Handle message reconstruction

rules:

- name: "TypeScript Strict Mode"
    pattern: "*.ts,*.tsx"
    rules:
  - "No 'any' types allowed"
  - "Use explicit return types"
  - "Enable strict null checks"
  - "Use interface over type where possible"

- name: "Code Organization"
    pattern: "src/**/*"
    rules:
  - "Use feature-based folder structure"
  - "Keep components pure and focused"
  - "Separate business logic from UI"
  - "Use hooks for shared logic"

- name: "API Design"
    pattern: "src/app/api/**/*"
    rules:
  - "Use proper HTTP methods"
  - "Validate inputs"
  - "Handle errors gracefully"
  - "Stream responses when appropriate"

- name: "State Management"
    pattern: "src/**/*"
    rules:
  - "Use React Query for server state"
  - "Use local state for UI"
  - "Avoid prop drilling"
  - "Keep state close to where it's used"

- name: "Testing"
    pattern: "**/*.test.ts,**/*.test.tsx"
    rules:
  - "Write unit tests for utils"
  - "Write integration tests for API"
  - "Test error cases"
  - "Mock external dependencies"

- name: "Documentation"
    pattern: "**/*"
    rules:
  - "Document public APIs"
  - "Add JSDoc for complex functions"
  - "Keep README up to date"
  - "Document environment setup"

- name: "Code Quality"
    pattern: "*.ts,*.tsx"
    rules:
  - "No while(true) loops - use explicit conditions"
  - "No constant conditions in loops or conditionals"
  - "Use proper loop termination conditions"
  - "Avoid infinite loops"
